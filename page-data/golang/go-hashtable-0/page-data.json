{"componentChunkName":"component---src-templates-blog-post-js","path":"/golang/go-hashtable-0/","result":{"data":{"site":{"siteMetadata":{"title":"Freckie et al.","author":"Freckie","siteUrl":"https://blog.frec.kr","comment":{"disqusShortName":"","utterances":"freckie/freckie.github.io"},"sponsor":{"buyMeACoffeeId":"freckie"}}},"markdownRemark":{"id":"9c4b2273-96e0-56ee-867f-ccb28ea71255","excerpt":"요약 Hash Table에서 해시 충돌(Hash Collision)에 대한 해결책으로 Open Addressing, Separate Chaining 등이 있다. Go에서는 Separate Chaining 방법으로 구현되어 있는데, 이 방법은 링크드 리스트와 같이 버킷의 엔트리에 엔트리를 붙이는 방법이다. 링크드 리스트나 트리의 구조로 chaining을 수행하는 다른 언어들과 달리 Go는 배열(Array)로 chaining을 수행한다. 한 버킷에는 8개의 tophash 배열과 Key…","html":"<h2 id=\"요약\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD\" aria-label=\"요약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h2>\n<ul>\n<li>\n<p>Hash Table에서 해시 충돌(Hash Collision)에 대한 해결책으로 Open Addressing, Separate Chaining 등이 있다.</p>\n<ul>\n<li>Go에서는 <strong>Separate Chaining</strong> 방법으로 구현되어 있는데, 이 방법은 링크드 리스트와 같이 버킷의 엔트리에 엔트리를 붙이는 방법이다.</li>\n<li>링크드 리스트나 트리의 구조로 chaining을 수행하는 다른 언어들과 달리 <strong>Go는 배열(Array)로 chaining을 수행</strong>한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<ul>\n<li>\n<p>한 버킷에는 <strong>8개의 tophash 배열과 Key 배열, Value 배열</strong>이 존재한다.</p>\n<ul>\n<li>한 버킷에 <strong>8개의 슬롯(slot)이 존재</strong>한다고 표현한다.</li>\n<li>\n<p>tophash 배열에 각 <strong>Key의 해시 값의 최상위 8비트를 저장</strong>해둔다.</p>\n<ul>\n<li>해시 충돌이 발생해 같은 버킷에 데이터를 저장할 경우, 그냥 비어있는 슬롯을 사용한다.</li>\n</ul>\n</li>\n<li>\n<p>버킷은 메모리 상에 Key와 Value를 한 쌍으로 저장하지 않고, Key들을 먼저 할당하고 그 뒤에 Value들을 모아서 할당해둔다.</p>\n<ul>\n<li>이는 <strong>메모리 정렬(memory alignment)의 효율</strong>을 얻기 위함이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<ul>\n<li>\n<p>Go 해시 테이블의 <strong>Load Factor는 6.5</strong>로 설정되어 있다.</p>\n<ul>\n<li>버킷 당 평균 Key-Value 슬롯 사용이 6.5개 이상이면 해시 테이블 <strong>사이즈를 두 배로 늘리는 growing 과정을 수행</strong>한다.</li>\n<li>\n<p><code class=\"language-text\">make(map[K]V, 100)</code>과 같이 맵 생성 시 Key-Value의 개수에 대해 힌트를 주는 경우, 런타임은 다음 과정을 통해 버킷 개수를 설정한다.</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>B</mi></msub><mtext> </mtext><mtext> </mtext><mi>L</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi>F</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>∗</mo><mi>B</mi><mo>≥</mo><mi>h</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">min_B \\,\\,LoadFactor * B \\ge hint</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">i</span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">L</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">h</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">t</span></span></span></span></li>\n<li>버킷 개수는 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>B</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span></span></span></span></span></span></span>개</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<ul>\n<li>\n<p>Key-Value 데이터에 접근하기 위해서 다음과 같이 포인터 연산을 하여 Value를 찾는다.</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><msub><mi>e</mi><mi>i</mi></msub><mo>=</mo><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>O</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi></mrow><mtext> </mtext><mo>+</mo><mtext> </mtext><mn>8</mn><mo>∗</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><mi>i</mi><mo>∗</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">value_i = {dataOffset}\\, +\\, 8 * keySize\\, +\\, i*elemSize</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">u</span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">t</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.04398em;\">z</span><span class=\"mord mathdefault\">e</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.04398em;\">z</span><span class=\"mord mathdefault\">e</span></span></span></span></li>\n</ul>\n</li>\n</ul>\n<br>\n<p>이번 포스팅에서는 <code class=\"language-text\">runtime/map.go</code> 파일을 훑어보며 Go에서 해시 테이블이 어떻게 구현되어 있는지 살펴본다.</p>\n<ol>\n<li><code class=\"language-text\">hmap</code>, <code class=\"language-text\">bmap</code>, <code class=\"language-text\">maptype</code>이 어떻게 정의되어 있는지 살펴본다.</li>\n<li>맵을 생성하는 <code class=\"language-text\">makemap()</code> 함수에 대해 살펴본다.</li>\n<li>키를 통해 맵에 접근하는 <code class=\"language-text\">mapaccess()</code> 계열 함수에 대해 살펴본다.</li>\n</ol>\n<br>\n<h2 id=\"1-hmap-struct\" style=\"position:relative;\"><a href=\"#1-hmap-struct\" aria-label=\"1 hmap struct permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. <em>hmap</em> struct</h2>\n<p>Go 런타임에서는 맵 생성 시 hmap이라는 구조체의 포인터를 리턴하며, 이 hmap은 맵의 헤더라고 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> hmap <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\tcount <span class=\"token builtin\">int</span>\n\tflags <span class=\"token builtin\">uint8</span>\n\tB <span class=\"token builtin\">uint8</span>\n\tnoverflow <span class=\"token builtin\">uint16</span>\n\thash0 <span class=\"token builtin\">uint32</span>\n\n\tbuckets unsafe<span class=\"token punctuation\">.</span>Pointer\n\toldbuckets unsafe<span class=\"token punctuation\">.</span>Pointer\n\tnevacuate <span class=\"token builtin\">uintptr</span>\n\n\textra <span class=\"token operator\">*</span>mapextra\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 알고넘어가야 할 중요한 필드들은 다음과 같다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">B</code> (<em>uint8</em>) : map이 가지는 버킷의 수에 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">log_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>를 취한 값.</p>\n<ul>\n<li>map이 최대 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>B</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span></span></span></span></span></span></span>개의 버킷을 가질 수 있도록 B값을 결정한다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">hash0</code> (<em>uint32</em>) : 해시 충돌을 피하기 위한 랜덤 시드.</li>\n<li><code class=\"language-text\">buckets</code> (<em>unsafe.Pointer</em>) : 실제 버킷들(array)을 가리키는 포인터.</li>\n<li><code class=\"language-text\">oldbuckets</code> (<em>unsafe.Pointer</em>) : 버킷이 충분히 많이 차서 해시 충돌이 우려될 경우 버킷 개수를 늘려 재할당하는데, 이 과정(growing)이 진행될 때 이전 버킷 array를 가리킴. growing이 진행되지 않을 때는 <code class=\"language-text\">nil</code>값을 가짐.</li>\n<li><code class=\"language-text\">nevacuate</code> (<em>uintptr</em>) : growing이 진행 중에 oldbuckets에서 새로운 buckets로 버킷이 옮겨가게 되는데, 다음으로 옮겨갈 버킷에 대한 주소를 가리킴.</li>\n<li><code class=\"language-text\">extra</code> (*mapextra) : 버킷의 수가 오버플로우되는 상황을 대비해서 미리 메모리 할당해둔 부분.</li>\n</ul>\n<br>\n<p>💡 (참고) <strong><code class=\"language-text\">uintptr</code> vs <code class=\"language-text\">unsafe.Pointer</code></strong></p>\n<ul>\n<li>uintptr은 builtin.go의 주석에 따르면 <strong>어떤 포인터든 주소를 담을 수 있게 충분히 큰 integer</strong> 타입이라고 한다.</li>\n<li>unsafe.Pointer는 <strong>임의의 포인터 타입</strong>(<code class=\"language-text\">*ArbitraryType</code>)을 표현하며, 실제 Go object를 가리키고 있다. C의 <code class=\"language-text\">*void</code> 처럼 어떤 타입의 포인터로든 변환할 수 있다.</li>\n<li>unsafe.Pointer는 Go object를 가리키는 포인터로서 동작하고 있기 때문에 <strong>Go의 가비지 컬렉터에게 추적</strong>된다. 그러나 uintptr는 단순히 주소를 담는 정수형 변수기 때문에 가비지 컬렉션될 수 없으며, 사용하기에 매우 위험하다.</li>\n</ul>\n<br>\n<h2 id=\"2-bmap-struct\" style=\"position:relative;\"><a href=\"#2-bmap-struct\" aria-label=\"2 bmap struct permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. <em>bmap</em> struct</h2>\n<p><em>bmap</em>은 Go 맵에서 버킷을 가리킨다.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> bmap <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\ttophash <span class=\"token punctuation\">[</span>bucketCnt<span class=\"token punctuation\">]</span><span class=\"token builtin\">uint8</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// bucketCnt는 8(1&lt;&lt;3)을 기본값으로 가진다.</span></code></pre></div>\n<p><code class=\"language-text\">bucketCnt</code>는 8을 기본값으로 가지며 한 버킷 당 저장할 수 있는 키-밸류 데이터 개수(<strong>슬롯 개수</strong>)를 뜻한다.</p>\n<p><code class=\"language-text\">tophash</code>는 이 버킷에 포함된 <strong>각 키의 해시 값에서 최상위 바이트(8비트)</strong>, 즉 키의 해시값에서 왼쪽부터 8비트를 가지고 있는 배열이다.</p>\n<p>이렇게 버킷 내의 키들에 대해 해시 값을 또 갖고 있는 이유는 Go에서의 해시테이블이 <strong>Separate Chaining</strong> 방식을 사용하는 다른 언어 구현체들과 다르게 버킷이 Linked List 기반이 아니고 그냥 <strong>Array</strong>이기 때문이다.</p>\n<br>\n<p>여기서 버킷이 실제 키-밸류 데이터를 담는 부분이라 <em>bmap</em>에 키 값과 밸류 값, 혹은 키와 밸류를 가리키는 포인터가 있을 것이라고 생각할 수 있다.</p>\n<p>그러나 <code class=\"language-text\">map.go</code> 코드 상의 구현에는 <em>bmap</em> struct의 필드로 <code class=\"language-text\">tophash</code>만이 존재하며 키와 밸류는 존재하지 않는다.</p>\n<p>그렇다면 키와 밸류는 어디에 저장되어 있을까?</p>\n<br>\n<p>실제로 <em>bmap</em>이 할당되는 과정이나 밸류를 갖고 오는 과정을 살펴보면 메모리 상에 다음과 같이 할당되어 있음을 알 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> bmap <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\ttophash <span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">uint8</span>\n<span class=\"token punctuation\">}</span>\nkeys <span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span>K\nvalues <span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span>V</code></pre></div>\n<p>코드 상에 keys와 values가 이렇게 나타나있지는 않지만 <strong><em>bmap</em>이 할당된 메모리 이후에 실제로 8개의 키 함께 할당되어 있고 그 후에 8개의 밸류가 선형적으로 할당</strong>되어 있는 것을 알 수 있다.</p>\n<br>\n<p>여기서 &#x3C; key0 | key1 | … | key7 | val0 | val 1 | … | val7 > 이렇게 키끼리 밸류끼리 묶는 것보다, &#x3C; key0 | val0 | … | key7 | val7 > 과 같이 키와 밸류를 교대하며 할당하는 것이 더 편하지 않을까 하는 의문이 들 수 있다.</p>\n<p>물론 키-밸류를 교대하며 각각을 한 쌍으로 할당하는 것이 데이터의 접근에 있어 코드가 덜 복잡하다.</p>\n<p>그러나 <code class=\"language-text\">map[int64]int8</code>과 같은 타입의 경우 키-밸류를 페어로 할당하면 &#x3C; 64비트 | 8비트 | 64비트 | 8비트 | … > 와 같이 할당되는데, <strong>메모리 정렬(memory alignment)</strong> 관점에서 봤을 때 비효율이 발생할 수밖에 없다.</p>\n<p>따라서 <code class=\"language-text\">map[int64]int8</code>을 Go의 구현대로 생성하면 &#x3C; 64비트 | 64비트 | … | 8비트 | 8비트 | … >와 같은 형태로 할당되어 패딩을 제거할 수 있어 더 효율적이다.</p>\n<br>\n<p>우선 지금은 <em>bmap</em>에 대해서 이 정도로만 알아보고 추후에 <code class=\"language-text\">mapaccess()</code>나 <code class=\"language-text\">mapassign()</code> 함수를 설명할 때 자세히 살펴보도록 하겠다.</p>\n<br>\n<h2 id=\"3-makemap--맵-생성하기\" style=\"position:relative;\"><a href=\"#3-makemap--%EB%A7%B5-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0\" aria-label=\"3 makemap  맵 생성하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. <em>makemap()</em> :: 맵 생성하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">m1 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span>v<span class=\"token punctuation\">)</span>\nm2 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span>v<span class=\"token punctuation\">,</span> <span class=\"token number\">1234</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Go에서 맵은 위 코드를 통해 생성한다. <code class=\"language-text\">m1</code>처럼 생성할 수도 있지만, 이렇게 생성되는 초기 맵 사이즈에 비해 담아야 할 값들이 많다면 맵이 growing 과정을 여러번 거칠 수 있어 효율성이 떨어질 수 있다.</p>\n<p>보다 나은 효율을 위해, <code class=\"language-text\">m2</code>처럼 값을 몇개를 담을건지 힌트(<strong><em>hint</em></strong>)를 주어 생성할 수 있다.\n<br></p>\n<p><code class=\"language-text\">make(map[k]v, hint)</code> 코드는 Go 런타임에서 <code class=\"language-text\">makemap()</code> 함수를 호출하게 한다.\n<code class=\"language-text\">makemap()</code> 함수의 전체 코드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// src/runtime/map.go</span>\n<span class=\"token comment\">// makemap() 전체 코드</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">makemap</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>maptype<span class=\"token punctuation\">,</span> hint <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> h <span class=\"token operator\">*</span>hmap<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>hmap <span class=\"token punctuation\">{</span>\n\tmem<span class=\"token punctuation\">,</span> overflow <span class=\"token operator\">:=</span> math<span class=\"token punctuation\">.</span><span class=\"token function\">MulUintptr</span><span class=\"token punctuation\">(</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>hint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">.</span>bucket<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> overflow <span class=\"token operator\">||</span> mem <span class=\"token operator\">></span> maxAlloc <span class=\"token punctuation\">{</span>\n\t\thint <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token comment\">// initialize Hmap</span>\n\t<span class=\"token keyword\">if</span> h <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\th <span class=\"token operator\">=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>hmap<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n\th<span class=\"token punctuation\">.</span>hash0 <span class=\"token operator\">=</span> <span class=\"token function\">fastrand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\t<span class=\"token comment\">// Find the size parameter B which will hold the requested # of elements.</span>\n\t<span class=\"token comment\">// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.</span>\n\tB <span class=\"token operator\">:=</span> <span class=\"token function\">uint8</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token function\">overLoadFactor</span><span class=\"token punctuation\">(</span>hint<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tB<span class=\"token operator\">++</span>\n\t<span class=\"token punctuation\">}</span>\n\th<span class=\"token punctuation\">.</span>B <span class=\"token operator\">=</span> B\n\n\t<span class=\"token comment\">// allocate initial hash table</span>\n\t<span class=\"token comment\">// if B == 0, the buckets field is allocated lazily later (in mapassign)</span>\n\t<span class=\"token comment\">// If hint is large zeroing this memory could take a while.</span>\n\t<span class=\"token keyword\">if</span> h<span class=\"token punctuation\">.</span>B <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">var</span> nextOverflow <span class=\"token operator\">*</span>bmap\n\t\th<span class=\"token punctuation\">.</span>buckets<span class=\"token punctuation\">,</span> nextOverflow <span class=\"token operator\">=</span> <span class=\"token function\">makeBucketArray</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">if</span> nextOverflow <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\t\th<span class=\"token punctuation\">.</span>extra <span class=\"token operator\">=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>mapextra<span class=\"token punctuation\">)</span>\n\t\t\th<span class=\"token punctuation\">.</span>extra<span class=\"token punctuation\">.</span>nextOverflow <span class=\"token operator\">=</span> nextOverflow\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span> h\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<p>파라미터로 <code class=\"language-text\">*maptype</code>, <code class=\"language-text\">int</code>, <code class=\"language-text\">*hmap</code>이 들어가는데, <code class=\"language-text\">maptype</code>은 <code class=\"language-text\">runtime/type.go</code>에 다음과 같이 정의되어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> maptype <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\ttyp    _type\n\tkey    <span class=\"token operator\">*</span>_type\n\telem   <span class=\"token operator\">*</span>_type\n\tbucket <span class=\"token operator\">*</span>_type <span class=\"token comment\">// internal type representing a hash bucket</span>\n\t<span class=\"token comment\">// function for hashing keys (ptr to key, seed) -> hash</span>\n\thasher     <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uintptr</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">uintptr</span>\n\tkeysize    <span class=\"token builtin\">uint8</span>  <span class=\"token comment\">// size of key slot</span>\n\telemsize   <span class=\"token builtin\">uint8</span>  <span class=\"token comment\">// size of elem slot</span>\n\tbucketsize <span class=\"token builtin\">uint16</span> <span class=\"token comment\">// size of bucket</span>\n\tflags      <span class=\"token builtin\">uint32</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h3 id=\"31-makemap---필요-메모리-계산\" style=\"position:relative;\"><a href=\"#31-makemap---%ED%95%84%EC%9A%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B3%84%EC%82%B0\" aria-label=\"31 makemap   필요 메모리 계산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.1. <em>makemap()</em> - 필요 메모리 계산</h3>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// makemap() 부분 1</span>\nmem<span class=\"token punctuation\">,</span> overflow <span class=\"token operator\">:=</span> math<span class=\"token punctuation\">.</span><span class=\"token function\">MulUintptr</span><span class=\"token punctuation\">(</span><span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>hint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> t<span class=\"token punctuation\">.</span>bucket<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> overflow <span class=\"token operator\">||</span> mem <span class=\"token operator\">></span> maxAlloc <span class=\"token punctuation\">{</span>\n\thint <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// ...</span></code></pre></div>\n<p><code class=\"language-text\">makemap()</code> 함수에서는 먼저 hint 값과 버킷의 사이즈를 기반으로 메모리가 얼마나 필요한지 계산한다.</p>\n<p>이 때, overflow가 발생하거나 계산된 메모리 양이 <code class=\"language-text\">maxAlloc</code>보다 크다면 <code class=\"language-text\">hint</code>가 0으로 변경되고 나중에 <code class=\"language-text\">B</code>도 0으로 계산되며, 버킷은 추후에 lazily allocated된다.</p>\n<p>(<code class=\"language-text\">maxAlloc</code>은 AMD64 시스템에서 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^{48}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></span>bit로 32TiB에 해당한다.[1])</p>\n<br>\n<h3 id=\"32-makemap---해시-테이블-초기화\" style=\"position:relative;\"><a href=\"#32-makemap---%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%B4%88%EA%B8%B0%ED%99%94\" aria-label=\"32 makemap   해시 테이블 초기화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2. <em>makemap()</em> - 해시 테이블 초기화</h3>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// makemap() 부분 2</span>\n<span class=\"token keyword\">if</span> h <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\th <span class=\"token operator\">=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>hmap<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\nh<span class=\"token punctuation\">.</span>hash0 <span class=\"token operator\">=</span> <span class=\"token function\">fastrand</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// ...</span></code></pre></div>\n<p>다음 부분에서 hmap을 할당하고, <code class=\"language-text\">hash0</code> (해시 시드)를 설정한다.</p>\n<p>(<a href=\"https://github.com/wangyi-fudan/wyhash\">wyhash</a>라는 알고리즘으로 랜덤 시드를 생성한다.)</p>\n<br>\n<h3 id=\"33-makemap---할당할-버킷-수-계산\" style=\"position:relative;\"><a href=\"#33-makemap---%ED%95%A0%EB%8B%B9%ED%95%A0-%EB%B2%84%ED%82%B7-%EC%88%98-%EA%B3%84%EC%82%B0\" aria-label=\"33 makemap   할당할 버킷 수 계산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.3. <em>makemap()</em> - 할당할 버킷 수 계산</h3>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// makemap() 부분 3</span>\nB <span class=\"token operator\">:=</span> <span class=\"token function\">uint8</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> <span class=\"token function\">overLoadFactor</span><span class=\"token punctuation\">(</span>hint<span class=\"token punctuation\">,</span> B<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tB<span class=\"token operator\">++</span>\n<span class=\"token punctuation\">}</span>\nh<span class=\"token punctuation\">.</span>B <span class=\"token operator\">=</span> B\n<span class=\"token comment\">// ...</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// overLoadFactor 함수는 같은 파일에 다음과 같이 구현되어 있다.</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">overLoadFactor</span><span class=\"token punctuation\">(</span>count <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> B <span class=\"token builtin\">uint</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> count <span class=\"token operator\">></span> bucketCnt <span class=\"token operator\">&amp;&amp;</span>\n\t\t<span class=\"token function\">uintptr</span><span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> loadFactorNum<span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token function\">bucketShift</span><span class=\"token punctuation\">(</span>B<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span>loadFactorDen<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>주어진 <code class=\"language-text\">hint</code>값을 토대로 <code class=\"language-text\">B</code>값을 결정하는데, hint개의 키-밸류 데이터를 충분히 저장할 수 있는 버킷의 수를 구하게 된다.</p>\n<p><code class=\"language-text\">map.go</code> 파일을 보면 윗부분에 <code class=\"language-text\">loadFactorNum</code>, <code class=\"language-text\">loadFactorDen</code> 이라는 정수형 상수가 정의되어 있다.</p>\n<p>기본으로 세팅된 값은 각각 13과 2로 <code class=\"language-text\">loadFactorNum</code>을 <code class=\"language-text\">loadFactorDen</code>으로 나누어 <strong>Load Factor</strong>를 결정한다.</p>\n<p><strong>Load Factor</strong>는 <strong>버킷 당 평균 키-밸류 데이터 개수</strong>를 뜻하며 Go에서는 이 값을 13/2 = <strong>6.5</strong>로 사용한다.</p>\n<p>결론적으로, 위 코드에서 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mi>o</mi><mi>a</mi><mi>d</mi><mi>F</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>∗</mo><mi>B</mi><mo>≥</mo><mi>h</mi><mi>i</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">LoadFactor * B \\ge hint</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">L</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">h</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">t</span></span></span></span>가 되는 최소 <code class=\"language-text\">B</code>를 구하게 되고, 맵은 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>B</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span></span></span></span></span></span></span>개의 버킷을 가질 수 있게 된다.</p>\n<br>\n<p>💡 (참고) <strong>Load Factor</strong></p>\n<ul>\n<li>Load Factor가 버킷 당 평균 키-밸류 데이터 개수를 뜻하는데 현재 맵에 저장된 데이터가 Load Factor를 넘어가게 된다면 맵은 자동으로 용량을 늘리게 된다. (growing 과정)</li>\n<li>만약 이 Load Factor가 너무 작다면 growing 과정이 자주 트리거되어 오버헤드가 발생하여 접근 시간이 낭비될 것이고, 너무 크다면 메모리 공간이 낭비될 것이다.</li>\n<li>즉, Load Factor에 따라 시간과 공간이 trade-off 관계에 놓이게 되며, 이 값을 적당히 조정하는 것이 성능을 좌우한다고 할 수 있다.</li>\n<li>Java에서는 HashTable의 Load Factor로 75%를 사용한다.</li>\n</ul>\n<br>\n<p>추가) <code class=\"language-text\">bucketShift(B)</code> 함수는 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>B</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.05017em;\">B</span></span></span></span></span></span></span></span></span></span></span>를 리턴하고 B의 범위는 32bit 시스템에서 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>B</mi><mo>≤</mo><mn>31</mn></mrow><annotation encoding=\"application/x-tex\">0 \\le B \\le 31</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">1</span></span></span></span>, 64bit 시스템에서 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>B</mi><mo>≤</mo><mn>63</mn></mrow><annotation encoding=\"application/x-tex\">0 \\le B \\le 63</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">6</span><span class=\"mord\">3</span></span></span></span>이다.</p>\n<p><code class=\"language-text\">B</code>의 정의가 버킷 개수에 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">log_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>를 취한 것이기 때문에 <code class=\"language-text\">bucketShift(B)</code> 함수의 역할은 <strong>주어진 B 값을 기반으로 가질 수 있는 버킷 개수를 계산</strong>하는 것이라고 할 수 있다.</p>\n<br>\n<h3 id=\"34-makemap---버킷-array-생성\" style=\"position:relative;\"><a href=\"#34-makemap---%EB%B2%84%ED%82%B7-array-%EC%83%9D%EC%84%B1\" aria-label=\"34 makemap   버킷 array 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.4. <em>makemap()</em> - 버킷 Array 생성</h3>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// makemap() 부분 4</span>\n<span class=\"token keyword\">if</span> h<span class=\"token punctuation\">.</span>B <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">var</span> nextOverflow <span class=\"token operator\">*</span>bmap\n\th<span class=\"token punctuation\">.</span>buckets<span class=\"token punctuation\">,</span> nextOverflow <span class=\"token operator\">=</span> <span class=\"token function\">makeBucketArray</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">.</span>B<span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">if</span> nextOverflow <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span>\n\t\th<span class=\"token punctuation\">.</span>extra <span class=\"token operator\">=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>mapextra<span class=\"token punctuation\">)</span>\n\t\th<span class=\"token punctuation\">.</span>extra<span class=\"token punctuation\">.</span>nextOverflow <span class=\"token operator\">=</span> nextOverflow\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">return</span> h</code></pre></div>\n<p>마지막 부분에서는 버킷 array를 생성하고 맵에 할당하는 과정이 포함되어 있다.</p>\n<p>만약 위에서 <code class=\"language-text\">B</code>값이 0으로 정해진다면 여기서 버킷 array를 생성하지 않고, 값을 넣는 <code class=\"language-text\">mapassign()</code> 과정에서 버킷을 생성한다고 한다. (lazy allocate)\n<br></p>\n<p><code class=\"language-text\">makemap()</code> 함수에 파라미터로 받았던 <code class=\"language-text\">t *maptype</code>, 위에서 계산했던 <code class=\"language-text\">B</code>값을 <code class=\"language-text\">makeBucketArray()</code> 함수에 넣으면, 해당 함수에서 버킷 사이즈를 계산하여 메모리를 할당하고 반환해준다.</p>\n<br>\n<p><code class=\"language-text\">makeBucketArray()</code> 함수에서 주목할 점은 버킷 개수가 충분히 클 때(<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>B</mi><mo>≥</mo><mn>4</mn></mrow><annotation encoding=\"application/x-tex\">B \\ge 4</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≥</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span></span></span></span>) 미리 overflow 버킷을 할당해둔다는 것이다.</p>\n<p>또한 해당 함수에서 <em>bmap</em>의 사이즈를 계산해서 메모리를 할당하는데, bmap struct 구현에는 필드가 tophash [8]uint8만 있지만 <strong>실제로는 8개의 키와 8개의 밸류를 담을 공간까지 계산</strong>하여 메모리를 할당한다.</p>\n<br>\n<h2 id=\"4-mapaccess--맵에-접근하기\" style=\"position:relative;\"><a href=\"#4-mapaccess--%EB%A7%B5%EC%97%90-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0\" aria-label=\"4 mapaccess  맵에 접근하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. <em>mapaccess()</em> :: 맵에 접근하기</h2>\n<p>2016년 GopherCon에서 Keith Randall은 다음과 같이 설명했다. [2]</p>\n<p>Generic이 존재하는 다른 언어 같은 경우 맵에서 특정 키에 대한 값을 갖고오고자 할 때(lookup), <code class=\"language-text\">v = m[k]</code> 코드는 다음과 같이 컴파일 될 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// lookup</span>\nv <span class=\"token operator\">=</span> m<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">// compiles to</span>\nv <span class=\"token operator\">=</span> runtime<span class=\"token punctuation\">.</span><span class=\"token function\">lookup</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// where the runtime has the function</span>\n<span class=\"token keyword\">func</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span> V<span class=\"token operator\">></span> <span class=\"token function\">lookup</span><span class=\"token punctuation\">(</span>m <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span>K<span class=\"token punctuation\">]</span>V<span class=\"token punctuation\">,</span> k K<span class=\"token punctuation\">)</span> V</code></pre></div>\n<p>그러나 Go에는 generic이 없으니 (1.18 이전) 위와 같은 개념과는 다르게 런타임을 구현해야했다.\n(Generic이 도입된 1.18에도 런타임에서 맵의 구현은 변경되지 않았다.)</p>\n<p>런타임에서 generic 타입의 값을 가질 수 없으니 <code class=\"language-text\">unsafe.Pointer</code>를 사용해서 런타임에 키에 대한 정보를 얻을 수 있도록 구현했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// lookup</span>\nv <span class=\"token operator\">=</span> m<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\">// compiles to</span>\npk <span class=\"token operator\">:=</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>k<span class=\"token punctuation\">)</span>\npv <span class=\"token operator\">:=</span> runtime<span class=\"token punctuation\">.</span><span class=\"token function\">lookup</span><span class=\"token punctuation\">(</span><span class=\"token function\">typeOf</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> pk<span class=\"token punctuation\">)</span>\nv <span class=\"token operator\">=</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>V<span class=\"token punctuation\">)</span>pv\n\n<span class=\"token comment\">// where the runtime has the function</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">lookup</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>mapType<span class=\"token punctuation\">,</span> m <span class=\"token operator\">*</span>mapHeader<span class=\"token punctuation\">,</span> k unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> unsafe<span class=\"token punctuation\">.</span>Pointer</code></pre></div>\n<p>특정 타입에 대해 따로 구현되어 있는 lookup 함수를 호출하는 대신, 단일로 존재하는 lookup 함수에 맵 타입, 헤더, 그리고 키에 대한 포인터를 파라미터로 입력함으로써 값에 대해 접근한다.</p>\n<p>키가 어떤 타입인지 런타임에 알 수 있으므로 파라미터에 키(k)가 unsafe.Pointer로 설정되어 있다.</p>\n<br>\n<p>실제 <code class=\"language-text\">map.go</code> 파일에는 맵 접근 함수가 리턴 타입에 따라 여러 버전으로 구현되어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// elem에 대한 포인터를 반환</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">mapaccess1</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>maptype<span class=\"token punctuation\">,</span> h <span class=\"token operator\">*</span>hmap<span class=\"token punctuation\">,</span> key unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> unsafe<span class=\"token punctuation\">.</span>Pointer\n\n<span class=\"token comment\">// key가 존재하는지에 대한 불린 값도 반환</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">mapaccess2</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>maptype<span class=\"token punctuation\">,</span> h <span class=\"token operator\">*</span>hmap<span class=\"token punctuation\">,</span> key unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">,</span> <span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// key와 elem 모두 map iterator를 이용하여 반환</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">mapaccessK</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>maptype<span class=\"token punctuation\">,</span> h <span class=\"token operator\">*</span>hmap<span class=\"token punctuation\">,</span> key unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">,</span> unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span></code></pre></div>\n<p>계획으로는 <code class=\"language-text\">mapaccess1()</code> 코드를 하나하나 살펴보려 했으나, 전문을 살펴보기에 코드가 조금 길어서 16년 GopherCon에서 발표한 자료[2]를 토대로 살펴보고자 한다.</p>\n<p>해당 자료는 pseudo code 느낌이 나기는 하지만 실제 구현에서 중요한 부분을 충실하게 담고 있기 때문에 이해에는 큰 문제가 없을 것이라 생각한다.</p>\n<p><em>lookup</em>을 <code class=\"language-text\">mapaccess</code>로, <em>mapHeader</em>를 <code class=\"language-text\">hmap</code>으로, <em>bucket</em>을 <code class=\"language-text\">bmap</code>으로 바꿔서 봐도 무방하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// lookup looks up a key in a map and returns a pointer to the associated value.</span>\n<span class=\"token comment\">// t = type of the map</span>\n<span class=\"token comment\">// m = map</span>\n<span class=\"token comment\">// key = pointer to key</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">lookup</span><span class=\"token punctuation\">(</span>t<span class=\"token operator\">*</span> mapType<span class=\"token punctuation\">,</span> m <span class=\"token operator\">*</span>mapHeader<span class=\"token punctuation\">,</span> key unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> unsafe<span class=\"token punctuation\">.</span>Pointer <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> m <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token operator\">||</span> m<span class=\"token punctuation\">.</span>count <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> zero\n\t<span class=\"token punctuation\">}</span>\n\n\thash <span class=\"token operator\">:=</span> t<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">.</span>seed<span class=\"token punctuation\">)</span> <span class=\"token comment\">// hash := hashfn(key)</span>\n\tbucket <span class=\"token operator\">:=</span> hash <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> m<span class=\"token punctuation\">.</span>log B<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// bucket := hash % nbuckets</span>\n\textra <span class=\"token operator\">:=</span> <span class=\"token function\">byte</span><span class=\"token punctuation\">(</span>hash <span class=\"token operator\">>></span> <span class=\"token number\">56</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// extra := top 8 bits of hash</span>\n\tb <span class=\"token operator\">:=</span> <span class=\"token punctuation\">(</span>bucket<span class=\"token punctuation\">)</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>buckets<span class=\"token punctuation\">,</span> bucket<span class=\"token operator\">*</span>t<span class=\"token punctuation\">.</span>bucketsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// b := &amp;m.buckets[bucket]</span>\n\nbucketloop<span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">;</span> b <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">;</span> b <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span>overflow <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> b<span class=\"token punctuation\">.</span>extra<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> extra <span class=\"token punctuation\">{</span> <span class=\"token comment\">// check 8 extra hash bits</span>\n\t\t\t<span class=\"token keyword\">continue</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\n\t\tk <span class=\"token operator\">:=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> dataOffset <span class=\"token operator\">+</span> i<span class=\"token operator\">*</span>t<span class=\"token punctuation\">.</span>keysize<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">if</span> t<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token comment\">// return pointer to value_i</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> dataOffset <span class=\"token operator\">+</span> <span class=\"token number\">8</span><span class=\"token operator\">*</span>t<span class=\"token punctuation\">.</span>keysize <span class=\"token operator\">+</span> i<span class=\"token operator\">*</span>t<span class=\"token punctuation\">.</span>valuesize<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> zero\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h3 id=\"41-mapaccess---버킷-탐색\" style=\"position:relative;\"><a href=\"#41-mapaccess---%EB%B2%84%ED%82%B7-%ED%83%90%EC%83%89\" aria-label=\"41 mapaccess   버킷 탐색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.1. <em>mapaccess()</em> - 버킷 탐색</h3>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// mapaccess() 부분 1</span>\nhash <span class=\"token operator\">:=</span> t<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">.</span>seed<span class=\"token punctuation\">)</span> <span class=\"token comment\">// hash := hashfn(key)</span>\nbucket <span class=\"token operator\">:=</span> hash <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> m<span class=\"token punctuation\">.</span>log B<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// bucket := hash % nbuckets</span>\nextra <span class=\"token operator\">:=</span> <span class=\"token function\">byte</span><span class=\"token punctuation\">(</span>hash <span class=\"token operator\">>></span> <span class=\"token number\">56</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// extra := top 8 bits of hash</span>\nb <span class=\"token operator\">:=</span> <span class=\"token punctuation\">(</span>bucket<span class=\"token punctuation\">)</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span>buckets<span class=\"token punctuation\">,</span> bucket<span class=\"token operator\">*</span>t<span class=\"token punctuation\">.</span>bucketsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// b := &amp;m.buckets[bucket]</span>\n<span class=\"token comment\">// ...</span></code></pre></div>\n<p>먼저 조회하고자 하는 키의 해시값을 계산하고 버킷의 개수와 모듈러 연산(%)을 하여 키가 위치한 버킷을 구한다. (해싱할 때 hmap 생성 시 설정했던 <code class=\"language-text\">hash0</code>이라는 랜덤 시드를 사용한다.)</p>\n<p>그리고 해시값의 최상위 8비트를 구하고 버킷의 주소를 가져온다.</p>\n<p>여기서 <code class=\"language-text\">add(p, x)</code> 함수는 <code class=\"language-text\">runtime/stubs.go</code> 파일에 포인터(p)를 x만큼 다음 주소로 옮기라는 의미로 구현되어 있다.</p>\n<br>\n<h3 id=\"42-mapaccess---키-탐색\" style=\"position:relative;\"><a href=\"#42-mapaccess---%ED%82%A4-%ED%83%90%EC%83%89\" aria-label=\"42 mapaccess   키 탐색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4.2. <em>mapaccess()</em> - 키 탐색</h3>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// mapaccess() 부분 2</span>\nbucketloop<span class=\"token punctuation\">:</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">;</span> b <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">;</span> b <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span>overflow <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> b<span class=\"token punctuation\">.</span>extra<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> extra <span class=\"token punctuation\">{</span> <span class=\"token comment\">// check 8 extra hash bits</span>\n\t\t\t<span class=\"token keyword\">continue</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\n\t\tk <span class=\"token operator\">:=</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> dataOffset <span class=\"token operator\">+</span> i<span class=\"token operator\">*</span>t<span class=\"token punctuation\">.</span>keysize<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token keyword\">if</span> t<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">equal</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token comment\">// return pointer to value_i</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> dataOffset <span class=\"token operator\">+</span> <span class=\"token number\">8</span><span class=\"token operator\">*</span>t<span class=\"token punctuation\">.</span>keysize <span class=\"token operator\">+</span> i<span class=\"token operator\">*</span>t<span class=\"token punctuation\">.</span>elemsize<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">return</span> zero</code></pre></div>\n<p>여기 <code class=\"language-text\">bucketloop</code>는 버킷 내부에서 키를 탐색하는 과정이다.</p>\n<p>찾고자하는 키의 해시값의 최상위 8비트를 b.extra 배열(실제로는 <code class=\"language-text\">tophash</code> 배열)에서 탐색하는데, <strong>버킷 내의 8개 슬롯에서 해당 키가 몇 번째 인덱스에 존재하는지</strong> 결과를 얻게 된다.</p>\n<p>그리고 키가 존재하는지 한 번 더 확인 후 다음 과정을 통해 밸류(elem)에 접근하여 포인터를 반환한다.</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><msub><mi>e</mi><mi>i</mi></msub><mo>=</mo><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>O</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><mi>t</mi></mrow><mtext> </mtext><mo>+</mo><mtext> </mtext><mn>8</mn><mo>∗</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><mi>i</mi><mo>∗</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">value_i = {dataOffset}\\, +\\, 8 * keySize\\, +\\, i*elemSize</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">u</span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">d</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">t</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.04398em;\">z</span><span class=\"mord mathdefault\">e</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.04398em;\">z</span><span class=\"mord mathdefault\">e</span></span></span></span></li>\n</ul>\n<br>\n<p><code class=\"language-text\">dataOffset</code>은 map.go 상단에 다음과 같이 상수로 정의되어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\">dataOffset <span class=\"token operator\">=</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Offsetof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n\tb bmap\n\tv <span class=\"token builtin\">int64</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span>v<span class=\"token punctuation\">)</span></code></pre></div>\n<p>이번 포스트의 1번 섹션에서 <em>bmap</em>에는 tophash만 구현되어 있고 키와 밸류에 대한 정보가 없다고 소개한 바 있다.</p>\n<p><code class=\"language-text\">dataOffset</code>이 bmap과 int64를 필드로 가지는 구조체에서 int64가 시작하는 위치의 오프셋을 가리키게 되므로, 키와 밸류에 대한 정보는 bmap 바깥에 저장된다는 것을 알 수 있다.</p>\n<br>\n<h2 id=\"5-mapassign--맵에-키-할당하기\" style=\"position:relative;\"><a href=\"#5-mapassign--%EB%A7%B5%EC%97%90-%ED%82%A4-%ED%95%A0%EB%8B%B9%ED%95%98%EA%B8%B0\" aria-label=\"5 mapassign  맵에 키 할당하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. <em>mapassign()</em> :: 맵에 키 할당하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">mapassign</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>maptype<span class=\"token punctuation\">,</span> h <span class=\"token operator\">*</span>hmap<span class=\"token punctuation\">,</span> key unsafe<span class=\"token punctuation\">.</span>Pointer<span class=\"token punctuation\">)</span> unsafe<span class=\"token punctuation\">.</span>Pointer</code></pre></div>\n<p><code class=\"language-text\">mapassign()</code> 함수는 인풋 파라미터와 리턴 값이 <code class=\"language-text\">mapaccess1()</code>과 같고 수행하는 기능 또한 유사하다.</p>\n<p>다만 <code class=\"language-text\">mapaccess1()</code>이 현재 존재하는 키를 찾아 밸류를 포인터로 돌려줬다면, <code class=\"language-text\">mapassign()</code>은 키가 존재할 경우 밸류에 대한 포인터를 돌려주고 <strong>키가 존재하지 않을 경우 버킷에 슬롯을 할당하는 과정이 추가</strong>되어 있다.</p>\n<p>또한 슬롯을 추가하기 전에 현재 맵이 Load Factor에 도달했거나 overflow 버킷이 너무 많을 경우 <strong>growing을 시작하는 과정을 포함</strong>한다.</p>\n<br>\n<p>이전에 <em>bmap</em>과 mapaccess 과정을 살펴볼 때 Go에서의 해시테이블은 Linked List가 아니라 버킷마다 8개의 슬롯을 가진 Array를 미리 할당하여 chaining을 구현한다고 소개했다.</p>\n<p>따라서 새로운 키를 할당할 시, 해시 충돌이 발생하여 같은 버킷에 키가 할당될 경우 mapassign() 함수는 mapaccess()와 마찬가지로 <strong>버킷 내부 Array를 선형 탐색하다 빈 슬롯에 단순히 키를 할당</strong>하는 방법을 사용한다.</p>\n<p>키를 할당하고 밸류가 들어갈 슬롯의 주소를 가리키는 포인터를 리턴하여 키를 할당하는 과정이 완료된다.</p>\n<br>\n<p>Java와 같이 링크드 리스트, 혹은 트리로 chaining이 구현되었다면 버킷에 키를 할당하는 과정이 보다 더 복잡했을 것이다.</p>\n<p>그러나 Go는 포인터 연산과 비트 연산이 언어 차원에서 지원되므로, <strong>미리 할당해둔 배열에 빈 공간(슬롯)을 찾아 값을 넣기만 하면 할당이 완료</strong>된다.</p>\n<br>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<p>이번 포스팅에서는 Go의 해시 테이블 구현에 대해 코드 기반으로 살펴보았다.</p>\n<p>글이 너무 길어져 growing 과정이나 맵 순회에 대해서는 다음 포스팅에서 다루고자 한다.</p>\n<br>\n<p><strong>References</strong></p>\n<ul>\n<li><a href=\"https://github.com/golang/go/blob/master/src/runtime/map.go\">golang/go :: src/runtime/map.go</a></li>\n<li><a href=\"https://medium.com/kalamsilicon/hash-tables-implementation-in-go-48c165c54553\">Hash Tables Implementation in Go</a></li>\n<li><a href=\"https://utcc.utoronto.ca/~cks/space/blog/programming/GoUintptrVsUnsafePointer\">Why Go cares about the difference between unsafe.Pointer and uintptr</a></li>\n<li><a href=\"https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics\">How the Go runtime implements maps efficiently (without generics)</a></li>\n</ul>\n<br>\n<ul>\n<li>[1] <a href=\"https://github.com/golang/go/blob/23756207fb68c34ae15a030319dc31248e21cf45/src/runtime/malloc.go#L225\">golang/go :: src/runtime/malloc.go</a> (accessed on 2022/04/06)</li>\n<li>[2] <a href=\"https://youtu.be/Tl7mi9QmLns\">Keith Randall, “Inside the Map Implementation”, GopherCon 2016.</a> (<a href=\"https://docs.google.com/presentation/d/1CxamWsvHReswNZc7N2HMV7WPFqS8pvlPVZcDegdC_T4/edit#slide=id.g15413b4d29_0_6\">slide</a>)</li>\n</ul>","frontmatter":{"title":"Go에서 해시 테이블(Map)은 어떻게 구현되어 있을까?","date":"2022년 04월 07일 작성","series":null}}},"pageContext":{"slug":"/golang/go-hashtable-0/","previous":{"fields":{"slug":"/cloud/service_2/"},"frontmatter":{"title":"쿠버네티스 서비스 2 | 쿲벖넶팂슶 Ep.4","category":"Cloud","draft":false}},"next":null}},"staticQueryHashes":["3128451518","521680639"]}