{"componentChunkName":"component---src-templates-blog-post-js","path":"/cloud/service_2/","result":{"data":{"site":{"siteMetadata":{"title":"Fr3ky's Lab.","author":"Freckie","siteUrl":"https://blog.frec.kr","comment":{"disqusShortName":"","utterances":"freckie/freckie.github.io"},"sponsor":{"buyMeACoffeeId":"freckie"}}},"markdownRemark":{"id":"74864af0-1466-5960-a516-438d34c5b747","excerpt":"이 포스팅은 Marko Lukša의 Kubernetes in Action (1st edition)에서 Chapter 5. Services: Enabling Clients to Discover and Talk to Pods를 기반으로 재구성하였습니다. 서비스에 관련된 내용은 총 3편의 시리즈로 포스팅할 예정입니다. 쿠버네티스 서비스 1 쿠버네티스 서비스…","html":"<p>이 포스팅은 Marko Lukša의 Kubernetes in Action (1st edition)에서 <em>Chapter 5. Services: Enabling Clients to Discover and Talk to Pods</em>를 기반으로 재구성하였습니다.</p>\n<p>서비스에 관련된 내용은 총 3편의 시리즈로 포스팅할 예정입니다.</p>\n<ul>\n<li><a href=\"https://blog.frec.kr/cloud/service_1/\">쿠버네티스 서비스 1</a></li>\n<li><strong>쿠버네티스 서비스 2</strong></li>\n<li><a href=\"https://blog.frec.kr/cloud/service_ingress/\">쿠버네티스 서비스 : 인그레스</a> (작성 중)</li>\n</ul>\n<hr>\n<h2 id=\"들어가기-전에\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84%EC%97%90\" aria-label=\"들어가기 전에 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가기 전에</h2>\n<p>지난 포스팅에서는 서비스라는 리소스에 대해 간략하게 알아봤고 가장 기본적인 서비스인 ClusterIP 타입의 서비스를 예시로 들었다. 다만 이 ClusterIP 타입은 이름에서도 알 수 있듯이 클러스터의 IP를 할당받는다. 다시 말하면, 서비스를 생성했는데 <strong>이 서비스는 클러스터 내부에서만 접속이 가능</strong>하다는 의미이다.</p>\n<p>지난 포스팅에서 소개했던 서비스의 사용 예시 중에 웹 서비스 예시가 있었다. 웹 프론트엔드 파드가 있었고 이 파드들은 API 서버를 구동 중인 백엔드 파드에 요청을 하는 구조였다. 이 API 서버 파드들을 클러스터 내부에서 사용하기 위해서 ClusterIP 타입의 서비스를 통해 노출하는 것은 적절했다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 886px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACDUlEQVQ4y4VT227aQBD1f7ef0D70rapKL89RH1JVCVGSBtImBhJoREsoEG7lEhvbgeALtnfXp7PLpYBQutJo7ZnROWeOxxq2DuMcURSB0XMsErAopJxAHMcIwxlFqIIxDt/3Yds2HMeBZVlwXRfa0Gmi3M7gV/c7qn0d7sSGILDw7BB+6hWE4BAswvRxjNFoCMPoYzy2CDBGkiSKaBmSSOuYFWRu9pC9+YR87QsejDZCAnBfPof74hlmPEZgDTAlIsu6x8ik5+kYURwpwPUjQbXtkbkQSCj4bIbA8+fsZIO8gyBQY0lLliFVyZo88l1LkCgmFZQUnOGi+Qep8wLenedxULlTzYXOAKlsHh+yBXwu11Wu1DPwNpND6uwS+z/r8IhQW4Et5DNiuzMs6LWmisrAJAUR2paDQr2N42IOV50uOGPo2g/Q6y1cVhso9+7h0UdajbwElPIFNZNUhL4HRl9WjsmjGIbdRb56hIjs8DxP3UJ6ydZG3gZkBCbEfHzpp5CeLmqeN8F41F/5LdfGNE3Y62uzG1DgX35+N5pDHJ78wNFJCbliA8EslFWlamNtngJc9/abfovX79N48zGNvX0dk0dve0E21+Z/gPLPMK0JBkOHdjDeqC97nvBwHXBeb3VMnGaL+Jq9RqncUj5vk+5UKJOcFnnZKBb521oPB8dXSJ9e46Lwm3rEToV/Afdy4Kpv0TqnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20210729 1\"\n        title=\"20210729 1\"\n        src=\"/static/ec05e81a97b54d87c501e968b17e21ba/cc155/20210729-1.png\"\n        srcset=\"/static/ec05e81a97b54d87c501e968b17e21ba/5a46d/20210729-1.png 300w,\n/static/ec05e81a97b54d87c501e968b17e21ba/0a47e/20210729-1.png 600w,\n/static/ec05e81a97b54d87c501e968b17e21ba/cc155/20210729-1.png 886w\"\n        sizes=\"(max-width: 886px) 100vw, 886px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>다만 웹 프론트엔드 서비스는 외부에서 클라이언트가 접근해야 할텐데, <strong>ClusterIP 타입 서비스로는 클러스터 외부로 노출할 수 없다</strong>는 단점이 있다. 다행히도 <em>NodePort</em> 타입, <em>LoadBalancer</em> 타입 서비스는 클러스터 외부로 노출이 가능하다.</p>\n<p>따라서 이번 포스팅에서는 두 가지 타입의 서비스를 소개하고자 하고, 그 전에 서비스를 구성하는 <strong><em>엔드포인트(Endpoints)</em></strong>라는 리소스와 그 확장 버전인 <strong><em>엔드포인트슬라이스(EndpointSlice)</em></strong>에 대해 먼저 간단히 소개한다.</p>\n<h2 id=\"4-endpoints-리소스\" style=\"position:relative;\"><a href=\"#4-endpoints-%EB%A6%AC%EC%86%8C%EC%8A%A4\" aria-label=\"4 endpoints 리소스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Endpoints 리소스</h2>\n<p>서비스와 파드는 우리가 생각하는 것처럼 직접 연결되어 있는 구조가 아니라, 실제로는 그 사이에 엔드포인트 리소스가 위치해서 관리한다고 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 872px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABbElEQVQoz3WRT2+bQBDF+f5foLdeeqtUNYrTQw+RqlZpm1DbUGNbdixs/mPAAQwkmMD+shAlUqX0SaO382Z35u2uMpo4nI8tPt3s+PjbZDSxGU2dIe/5QnP5OvP4ontc6D7nU4/PY5ezsSPD5sOVyfvvG95drvm2DFHiKOKQJJTFkSSOOebZkO/DACE6XtCcarI0Hep5liK6lregbLdbXNelaZpXcS+HOI4zrIUQA2dZhqZpzGYGhmFQ16dB94MA0zTZ7ayhh2JbFoEU27Z9PRxLp5vNhjzPh7yvlUXBerXC931Op+dmXdcNmqqqzOdzOaRGieKETvxrOz8WuJ5HEO453KV0vI1OGojk8yyWSyxprB+khD8uSSbXVAud5naB2N2SzybEf35RGFMi9SfV8i/lXJOsc5S1nvv99dog11Ua2+RRun3srxxuTez1ijTwqQ4JbVVwf3eglg/Pwz3ioaKryv9GWxYI+WEveAIJEQrh/G7H8wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20210729 2\"\n        title=\"20210729 2\"\n        src=\"/static/aae4a53d86ae38ad4e2d5ddcacf2a124/65654/20210729-2.png\"\n        srcset=\"/static/aae4a53d86ae38ad4e2d5ddcacf2a124/5a46d/20210729-2.png 300w,\n/static/aae4a53d86ae38ad4e2d5ddcacf2a124/0a47e/20210729-2.png 600w,\n/static/aae4a53d86ae38ad4e2d5ddcacf2a124/65654/20210729-2.png 872w\"\n        sizes=\"(max-width: 872px) 100vw, 872px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>책에서 생성한 서비스를 <code class=\"language-text\">kubectl describe</code> 명령을 통해 확인한 예시이다. 서비스 하위에 Endpoints라는 항목이 <strong>서비스와 연결된 파드들의 IP와 포트를 리스트 형태</strong>로 가지고 있다. 쿠버네티스는 서비스에 요청이 들어오면 이 엔드포인트 중 하나로 리다이렉트한다.</p>\n<p>쿠버네티스에서는 서비스와 엔드포인트의 연결 관리를 프록시 모듈에서 수행하고 있다. (<code class=\"language-text\">/pkg/proxy/endpoints.go</code>)</p>\n<h2 id=\"5-endpointslice-리소스\" style=\"position:relative;\"><a href=\"#5-endpointslice-%EB%A6%AC%EC%86%8C%EC%8A%A4\" aria-label=\"5 endpointslice 리소스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. EndpointSlice 리소스</h2>\n<p>엔드포인트 리소스는 위에서 언급한대로 서비스와 연결된 파드의 IP, 포트를 가지고 있다. 다만 쿠버네티스 클러스터에서 서비스가 초창기 설계보다 더 많은 수의 파드로 더 많은 트래픽을 전송하는 방향으로 성장함에 따라, 엔드포인트 리소스가 처리할 수 있는 한계에 도달했다고 한다. [1]</p>\n<p>서비스에 연결된 모든 네트워크 엔드포인트가 한 엔드포인트 리소스에 연결되다보니 엔드포인트가 변경될 때 성능에 큰 영향을 미쳤다고 공식 문서에서 표현하고 있다.</p>\n<p>엔드포인트슬라이스는 <strong>기존의 엔드포인트를 포함</strong>하는 형태로 한 단계 더 추상화된 리소스이다. 기본적으로 엔드포인트슬라이스는 각각 100개 이하의 엔드포인트를 가지도록 관리된다.</p>\n<h2 id=\"6-nodeport-타입-서비스\" style=\"position:relative;\"><a href=\"#6-nodeport-%ED%83%80%EC%9E%85-%EC%84%9C%EB%B9%84%EC%8A%A4\" aria-label=\"6 nodeport 타입 서비스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. NodePort 타입 서비스</h2>\n<p>이제 NodePort 타입의 서비스를 이용해서 클러스터 외부로 서비스 리소스를 노출하는 방법에 대해 알아보고자 한다. </p>\n<p>NodePort 타입은 기본형 서비스였던 <strong>ClusterIP 타입 서비스를 기반</strong>으로 하고 있다. ClusterIP 타입 서비스가 생성되고 이 서비스를 노드(Node)의 특정한 포트와 연결한다. 예시로, NodePort를 30123으로 설정한다면 <strong>클러스터를 구성하고 있는 모든 노드</strong>의 30123 포트와 서비스가 연결된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABUUlEQVQoz4WR/UrDMBTF+/7vIPgAguCUTUFw+J9Oi3Nzg7br+pmka7pu1X53xyTCYGjxwiHh3uR3z0200TvBcBriVqwXzy6uXj0MdA+XE1fkA8j6/QfDUKx3sxDXuo+RyMvaQOzPHy2ls7Gp7mg8jsE3EbYJR1UWOInDARGjCANfqWsb/BcaoQy24yLiHHlVIS9KlGWpim3bghACSimCIEAl6sdeqt/hl7QtCZH6DjJGsA88pBFDWdXKXdd1yPMcruvCcRxYlgXbtpGmqWqGP6AaWeowxjdgsyfQyQMyauOryRWsaRrUdQ0u3EuHYRgqMcb6gclnAp8SbHiiRi7KCnHKxEg/ByS4KAqsVius12ssl0vE4t3RN3Ky3+Bt/oLpXIdPHNieqYASJF2ZpqlkGMZxLy/2AqX1KIrAxS9nWXbyYxK4WCyOoCRJsNvtVLM+4Dfi3Vy6rF4GPAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20210729 3\"\n        title=\"20210729 3\"\n        src=\"/static/59acd0a185844d5efdbf26e99db602f0/1cfc2/20210729-3.png\"\n        srcset=\"/static/59acd0a185844d5efdbf26e99db602f0/5a46d/20210729-3.png 300w,\n/static/59acd0a185844d5efdbf26e99db602f0/0a47e/20210729-3.png 600w,\n/static/59acd0a185844d5efdbf26e99db602f0/1cfc2/20210729-3.png 900w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>책에서 제시하는 NodePort 타입 서비스의 YAML 파일 예시인데, 타입이 ClusterIP에서 NodePort로 설정된 것과, <code class=\"language-text\">spec.ports</code> 항목에서 <code class=\"language-text\">nodePort</code> 값이 추가된 것 정도가 변경된 점이다. 만약 <code class=\"language-text\">nodePort</code> 항목을 설정하지 않는다면 쿠버네티스가 <strong>30000-32767</strong> 범위 내에서 자동으로 할당할 것이다. 이 범위는 <em>kube-apiserver</em>의 설정을 바꿈으로써 변경할 수 있다. (방법에 대해서는 <a href=\"https://blog.frec.kr/cloud/modify_nodeport_range/\">7월 23일 포스팅</a>을 참고)</p>\n<p>위의 YAML 파일을 통해 생성된 NodePort 서비스로 요청이 들어올 경우, 연결된 파드로 라우팅되는 과정은 다음 그림과 같을 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 853px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 77.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC10lEQVQ4y3WUyW7bQAyG/f5P0ALtLSiKHooutyJAgSCNEzuJ7cSy5E3raN9l2ZYsOX9JOQZyaAkREjDkRw7nH/Xquka136M9HDG3hrgcXeD3+DNu5G/IihiHukFVVWjbFnh5oef/fjwe0dsTrKGPIwAvNSDpfcjGAEt7hKreMQOHwwG73Q6EREN+fME/gVy0t8lztEWGJvKxTzPstzV2ZYVtuUeeFyiKAryLbVmiSSK05GWaIC9Oa2fPs7wr2iuEgVZ5wnZ4Dev2CpYQsG0Bx3HguR5c10VDlevQRys9YvdwA+f+FoLWhWXBIrdtu3tvNhvqUF3CWy9hayr8p0f4BEjSFFEcwvYEPM+lynschA7f0GDOFbjje3iBD8934NM7CAKEYYiSgVWRA7TlNouRWGa36Pk+ZuoEijVCWgQ0mxpl5KJ0aTepjyaPIAIVg9kVVGtFOWGXcwLSfNjq9kjVuBI5LWqmAsdbUycWza/oOk6yBFVTodjkcEMTK+sZgW9jk2UIqdNuyywZNqYbpqDZ+Hhem7hbLvFHkaGaVicrlk5d1djT4B03gOV4GNOoRrqJsSGwtkR3cD0OZDtQp1NFhSzJ+DKY4d1QxofxChNdkE5aNM1Jj+yzhYHZVMLPhzneDxV8HM1xu9RQbbcnIMmK5tRAszys9ACDuYX+2sANuWY7aAnGQNYZxxkihC5i9GUDv2ZrXCprSKqO3RnIxgl8UsKNEEUxCtJaQacdx1EnbBZup0dKmioa7obP+Nqf4mK0wKfJAverNx2+BWYEymjILJ04SQgedeM4G8ctNQfKQsM1dfhdUvGDupyoBl2KN0DugiWTEMQwDAgSePIKrN8Au7gwgukkWK11mLqGhGJ8z3s95VcgzyeO4+5mKLIMmZy/GcqQs3FcSrtgwXOcJEkwTbMrXPIp8/3jDjiJfxTs/N39hagYj4GvlktXjeG85XPcOY/jmMPz/QuZUmeOuM7EmAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20210729 4\"\n        title=\"20210729 4\"\n        src=\"/static/7596eb7d7c36c89e4fbb3b06e7bab616/66caf/20210729-4.png\"\n        srcset=\"/static/7596eb7d7c36c89e4fbb3b06e7bab616/5a46d/20210729-4.png 300w,\n/static/7596eb7d7c36c89e4fbb3b06e7bab616/0a47e/20210729-4.png 600w,\n/static/7596eb7d7c36c89e4fbb3b06e7bab616/66caf/20210729-4.png 853w\"\n        sizes=\"(max-width: 853px) 100vw, 853px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>간단히 표시하면 <strong>{클라이언트} → {노드IP:노드포트} → {ClusterIP:포트} → {파드IP:포트}</strong> 의 구조이다.</p>\n<p>이 서비스의 ClusterIP가 <code class=\"language-text\">10.11.254.223</code>으로 할당되었다고 가정하자. (NodePort 서비스는 ClusterIP 서비스 위에서 구현되었으므로 ClusterIP가 할당된다.) 우리는 이 서비스에 다음과 같이 접속할 수 있다.</p>\n<ul>\n<li>10.11.254.233 : 80 <strong>(클러스터 내부)</strong></li>\n<li>130.211.97.55 : 30123 <strong>(클러스터 외부)</strong></li>\n<li>130.211.99.206 : 30123 <strong>(클러스터 외부)</strong></li>\n</ul>\n<p>첫번째 주소는 내부에 생성된 ClusterIP 서비스의 주소이다. 물론 클러스터 내부에서만 접속할 수 있다. 두번째 주소와 세번째 주소는 각 노드의 IP와 포트이다. 이를 통해 클러스터 외부에서 접속할 수 있다.</p>\n<h2 id=\"7-loadbalancer-타입-서비스\" style=\"position:relative;\"><a href=\"#7-loadbalancer-%ED%83%80%EC%9E%85-%EC%84%9C%EB%B9%84%EC%8A%A4\" aria-label=\"7 loadbalancer 타입 서비스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. LoadBalancer 타입 서비스</h2>\n<p>LoadBalancer 타입 또한 클러스터 외부에서 접속할 수 있으며 <strong>NodePort 타입 서비스를 확장</strong>하여 구현되었다. NodePort 서비스가 ClusterIP 서비스를 기초로 하고 있기 때문에 이 LoadBalancer 서비스 또한 ClusterIP와 NodePort가 모두 설정된다.</p>\n<p>구글 클라우드 플랫폼(GCP), 아마존 웹 서비스(AWS), 마이크로소프트 Azure 등 상용 클라우드 서비스를 이용하는 경우, 이 클라우드 프로바이더들이 제공하는 로드 밸런서(Load Balancer)를 사용할 수도 있을 것이다.</p>\n<p>쿠버네티스에서는 이러한 <strong>외부 로드 밸런서를 서비스 리소스와 연결</strong>할 수 있도록 LoadBalancer 타입 서비스를 지원한다. </p>\n<p>LoadBalancer 서비스를 사용한 구조는 다음과 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 845px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAACqklEQVQ4y41UXW/TQBDM//8FiBcqQJRXHhDQKgKqijYQaIlwUuw4Tuwk/rbjfNpO0mHnEkepEBUnre/Otzc7O7t2bbvdYrvdgGMY6fjw/QT1m1N8bJ0inIzUe/rc39//l9X4qMaiSNH3W7DcFoZxB3k5x/E49v3XqK3Xa9DKssSvzhBXjS4uv3Rw9dWEYXpyVsrZWrGsQB9luFwuD4D1zy2cvDrDi9fnMp/juqkTQp3leXG49CjDaZahYhkEIcauD9cLMB578DwfSZKAQefzOYqiUH7T6RRxHKuzyrifTCao8VFdsCwLw6EjYGO4Ls2V/RCLxUIBrVYrtbZt+8gGcBxHme/7u5SDIBA2ngLiXEWL40ScAsVos9kgDMPdZQHinSiKlC+BqnWNaVS6kDod6UDgSZaIdnNhtxRmGdI0lPVKNF1KVlPx81RA+lYBanmeqwqSgS8HZBEIoC8pJ6FoGAXIBJgWybooVmqdpjHiKEQsQJMkRirsDoBkyJnpeKKb1rPQ6PZxrVtoWwPMJeVSNKw6gqwY1HSGaFqOMq3vSIAjhjSKrLc1vL/R8KTZUXbRHWCzWoKiVICuZHInfp9+/MSzWwNPm228bfcU4wMgWZJyJsWwpGUa5gCNno3fzgi5AG7lnHpzpGmKmbC2pa3qHRP1ux6+GRaSOHoISP1YqVQ0yaRAU7mYyJ6twkHfXFqH3WAaOi5uW3h5q+P5zR3OBPhByjuGoao0GaRsG1mH4rTcA1afXiRBRo6NTt/GO32AN5qJS6P/t4YVQ2rJJqcEtIohweiX7oO6wrRnGAilfaJw3zbFvsrHfWjoOtqahtFopAKsRMPjkcnnyl7tdrvQpDimaSow3q/xcyJLVo8z90VZqB8Ci0AmbCfqxmC793u/otj/OHJls9kMfwASCAZFykVWtAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20210729 5\"\n        title=\"20210729 5\"\n        src=\"/static/44d42c8d49abe9fd7f020fa81809a62f/8bd7c/20210729-5.png\"\n        srcset=\"/static/44d42c8d49abe9fd7f020fa81809a62f/5a46d/20210729-5.png 300w,\n/static/44d42c8d49abe9fd7f020fa81809a62f/0a47e/20210729-5.png 600w,\n/static/44d42c8d49abe9fd7f020fa81809a62f/8bd7c/20210729-5.png 845w\"\n        sizes=\"(max-width: 845px) 100vw, 845px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위에서 소개했던 NodePort의 구조와 거의 유사하나 한 가지 컴포넌트가 추가됐다. 외부 로드 밸런서가 NodePort 서비스의 위에서 동작하는데, 이는 외부에서 접속 가능한 단일 IP와 포트를 클라우드 프로바이더로부터 할당받아 사용한다.</p>\n<p>클라이언트에서 외부 로드밸런서, 즉 130.211.53.173:80로 요청을 보내면 로드 밸런서는 NodePort를 통해 서비스로 요청을 리다이렉트한다. 현재 서비스의 처리량을 상회할만큼의 많은 요청이 들어오면 로드 밸런서는 설정된 정책에 따라 라우팅할 노드를 선택하는 등 부하 분산을 수행한다.</p>\n<h2 id=\"마치며\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치며</h2>\n<p>이번 포스팅에서는 서비스와 연결된 <em>엔드포인트(Endpoint)</em>와 <em>엔드포인트슬라이스(EndpointSlice)</em>를 알아보았고, 서비스의 다른 타입인 <em>NodePort</em>와 <em>LoadBalancer</em>에 대해 살펴봤다. 두 타입의 서비스를 통해 이전 포스팅에서는 불가능했던 <strong>서비스의 클러스터 외부 노출</strong>을 가능하게 만들었다. 그러나 이들은 <strong>L4 계층(네트워크 계층)에서 TCP, UDP 패킷</strong>을 다룬다.</p>\n<p>다음 포스팅에서는 서비스보다 한 단계 더 추상화된 리소스로, <strong>L7 계층(애플리케이션 계층)에서 HTTP 패킷을 로드밸런싱</strong>을 수행하는 Ingress라는 리소스에 대해 살펴볼 예정이다.</p>\n<hr>\n<h3 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h3>\n<ul>\n<li>[1] <a href=\"https://kubernetes.io/ko/docs/concepts/services-networking/endpoint-slices/\">https://kubernetes.io/ko/docs/concepts/services-networking/endpoint-slices/</a></li>\n<li>[이미지 1-5] M. Lukša, Kubernetes in Action, Manning Publications, 2018.</li>\n</ul>","frontmatter":{"title":"쿠버네티스 서비스 2 | 쿲벖넶팂슶 Ep.4","date":"July 29, 2021"}}},"pageContext":{"slug":"/cloud/service_2/","previous":{"fields":{"slug":"/cloud/service_1/"},"frontmatter":{"title":"쿠버네티스 서비스 1 | 쿲벖넶팂슶 Ep.3","category":"Cloud","draft":false}},"next":null}},"staticQueryHashes":["3128451518","521680639"]}