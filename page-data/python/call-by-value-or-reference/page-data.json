{"componentChunkName":"component---src-templates-blog-post-js","path":"/python/call-by-value-or-reference/","result":{"data":{"site":{"siteMetadata":{"title":"Fr3ky's Lab.","author":"Freckie","siteUrl":"https://blog.frec.kr","comment":{"disqusShortName":"","utterances":"freckie/freckie.github.io"},"sponsor":{"buyMeACoffeeId":"freckie"}}},"markdownRemark":{"id":"75ebc139-a795-5843-8ecc-6ea123dba24b","excerpt":"파이썬에서는 함수 파라미터 작동을 어떻게 하는지 찾아보다 괜찮은 글이 있어 가져와 보았다. ( 이글 댓글창에서도 의견이 분분하지만 적어도 내가 생각하는 바와 비슷해서 옮겨왔다. / 발번역 ) 출처 : https://jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/ 파이썬은 Call-by-value나 call-by-reference로 작동할까? 둘 다 아니다. C나 Java…","html":"<p>파이썬에서는 함수 파라미터 작동을 어떻게 하는지 찾아보다 괜찮은 글이 있어 가져와 보았다. ( 이글 댓글창에서도 의견이 분분하지만 적어도 내가 생각하는 바와 비슷해서 옮겨왔다. / 발번역 )</p>\n<p>출처 : <a href=\"https://jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/\">https://jeffknupp.com/blog/2012/11/13/is-python-callbyvalue-or-callbyreference-neither/</a></p>\n<h2 id=\"파이썬은-call-by-value나-call-by-reference로-작동할까-둘-다-아니다\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%80-call-by-value%EB%82%98-call-by-reference%EB%A1%9C-%EC%9E%91%EB%8F%99%ED%95%A0%EA%B9%8C-%EB%91%98-%EB%8B%A4-%EC%95%84%EB%8B%88%EB%8B%A4\" aria-label=\"파이썬은 call by value나 call by reference로 작동할까 둘 다 아니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파이썬은 Call-by-value나 call-by-reference로 작동할까? 둘 다 아니다.</h2>\n<p>C나 Java 같은 언어에서 넘어온 개발자들이 파이썬 프로그래밍을 할 때 실수를 저지르는 것 중 하나는, 파이썬 함수에서 파라미터를 넘기는 방식에 대한 것이다. 더 기초적인 레벨에서, 이런 혼동은 파이썬의 객체 중심적 데이터 모델(object-centric data model)에 대한 오해에서 기인한다. 누군가 파이썬 함수의 호출 방식이 <em>“call-by-value”</em> 인지, <em>“call-by-reference”</em>인지 질문을 한다면, <strong>둘다 아니다</strong>가 정확한 답이 될 것이다. 사실은, 이런 용어들을 파이썬의 모델에 끼워넣기식 번역을 하는 것은 파이썬을 제대로 이해하지 못한 탓이다. <em>“call-by-object”</em>나 <em>“call-by-object-reference”</em>가 파이썬의 방식을 설명하기에 더 적합한 용어일 것이다. 그러면 <em>“call-by-object”</em>가 무슨 뜻일까?  </p>\n<p>파이썬에서는 (거의) 대부분이 객체다. 우리가 파이썬에서 보통 “변수”라고 부르던 것은 더 정확히는 <em>이름(names)</em>이다. 비슷하게 <em>대입(assignment)</em>은 실제로 객체에 이름을 <em>바인딩(binding, 연결)</em> 하는 것일뿐이다. 각각의 바인딩에는 바인딩이 유지되는 <em>스코프(scope)</em> (보통 이름이 시작되는 블록)가 있다.  </p>\n<p>한 번에 많은 용어들을 사용했지만 이런 기본 용어들이 파이썬 실행 모델의 기초를 형성한다. 그리고 C++과 비교했을 때의 차이는 미묘하지만 중요하다. 다음은 이러한 차이를 강조하는 구체적인 예제이다. 다음 C++ 예제가 실행될 때 일어날 일을 생각해보자.  </p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\">string some_guy <span class=\"token operator\">=</span> <span class=\"token string\">\"Fred\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ...</span>\nsome_guy <span class=\"token operator\">=</span> <span class=\"token string\">\"George\"</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위의 예제에서 <code class=\"language-text\">some_guy</code> 변수는 메모리의 한 위치를 가리키고 ‘Fred’라는 값은 그 위치에 삽입되어 있는 데이터이다 (실제로 우리는 <code class=\"language-text\">some_guy</code> 의 주소를 이용해서 참조되는 메모리 위치를 얻을 수 있다). 그리고 <code class=\"language-text\">some_guy</code> 가 가리키는 메모리 위치의 컨텐츠는 ‘George’ 로 바뀐다. 이전의 값은 더 이상 존재하지 않으며 새로운 값으로 덮어쓰기된 것이다. 아마 이 방법이 우리가 직관적으로 생각하던 방법에 더 가까울 것이다.  </p>\n<p>이번에는 위와 비슷한 파이썬 코드를 보자.  </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">some_guy <span class=\"token operator\">=</span> <span class=\"token string\">'Fred'</span>\n<span class=\"token comment\"># ...</span>\nsome_guy <span class=\"token operator\">=</span> <span class=\"token string\">'George'</span></code></pre></div>\n<h2 id=\"객체에-이름을-바인딩하기\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4%EC%97%90-%EC%9D%B4%EB%A6%84%EC%9D%84-%EB%B0%94%EC%9D%B8%EB%94%A9%ED%95%98%EA%B8%B0\" aria-label=\"객체에 이름을 바인딩하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체에 이름을 바인딩하기</h2>\n<p>첫째 줄에서 우리는 <code class=\"language-text\">some_guy</code> 라는 이름과, ‘Fred’ 값을 포함하는 문자열 객체를 바인딩했다. 프로그램의 맥락에서 보면 환경이 바뀐 것이다. 문자열 객체와 <code class=\"language-text\">some_guy</code> 라는 이름의 바인딩이 구문이 실행된 블록의 스코프에서 만들어졌다. 그 후에 <code class=\"language-text\">some_guy = &#39;George&#39;</code> 구문을 실행할 때, ‘Fred’ 값을 가지는 문자열 객체는 영향을 받지 않는 상태가 된다 (<em>unaffected</em>). 우리는 단지 <code class=\"language-text\">some_guy</code> 이름의 바인딩을 바꿨을 뿐이다! 그러나 우리는 <strong>‘Fred’나 ‘George’ 문자열 객체를 바꾸지는 않았다</strong>. 우리의 입장에서 그 객체들은 무제한으로 살아있게 된다.  </p>\n<p>너무 지나치게 세세한 것에 신경쓰는 것 같아 보일 수 있지만, 바인딩이 공유되거나 함수가 호출될 경우에는 단 하나의 바인딩을 하는 것이 더 중요할 것이다. 다음 파이썬 코드를 보고 다시 생각해보자.  </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">some_guy <span class=\"token operator\">=</span> <span class=\"token string\">'Fred'</span>\n\nfirst_names <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nfirst_names<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>some_guy<span class=\"token punctuation\">)</span>\n\nanother_list_of_names <span class=\"token operator\">=</span> first_names\nanother_list_of_names<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span>\nsome_guy <span class=\"token operator\">=</span> <span class=\"token string\">'Bill'</span>\n\n<span class=\"token keyword\">print</span> <span class=\"token punctuation\">(</span>some_guy<span class=\"token punctuation\">,</span> first_names<span class=\"token punctuation\">,</span> another_list_of_names<span class=\"token punctuation\">)</span></code></pre></div>\n<p>마지막 줄에서는 무슨 결과가 출력되었을까? 처음부터 보자면 ‘Fred’ 문자열 객체와 <code class=\"language-text\">some_guy</code> 이름의 바인딩이 블록의 <em>namespace</em>에 추가되었고, 그 뒤 <code class=\"language-text\">first_name</code> 이라는 이름이 빈 리스트 객체에 바인딩되었다. 4번째 줄에서는 <code class=\"language-text\">first_name</code>라는 이름이 바인딩된 리스트 객체에 <code class=\"language-text\">some_guy</code>가 바인딩 된 객체를 추가하는 함수가 호출된다. 이 부분에서, 실재하는 객체는 문자열과 리스트 객체 단 두 개 뿐이다. 그리고 <code class=\"language-text\">some_guy</code>와 <code class=\"language-text\">first_name[0]</code>은 둘 다 같은 객체를 가리킨다.  </p>\n<p>(실제로 <code class=\"language-text\">print(some_guy is first_names[0])</code> 구문의 결과가 이를 증명한다)  </p>\n<p>계속 분석해보자. 6번째 줄에서는 <code class=\"language-text\">another_list_of_names</code>라는 새로운 이름이 바인딩 된다. 이름간의 대입은 새로운 객체를 만들지 않는다. 이 이름들은 단순히 같은 객체에 바인딩된 것 뿐이다. 결과적으로 문자열 객체와 리스트 객체, 여전히 이 두 개만이 인터프리터에 의해 만들어진 객체가 된다. 7번째 줄에서는 <code class=\"language-text\">another_list_of_names</code>가 바인딩된 객체의 멤버 함수가 호출되며, ‘George’ 라는 새 객체를 추가하도록 변경된다. 그래서 아까 전의 질문에 대답하기 위해 코드의 출력 결과를 보면 다음과 같다.  </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Bill <span class=\"token punctuation\">[</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'George'</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'George'</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>이 결과는 파이썬에서는 실제로 두 가지 종류의 객체가 있다는 중요한 점을 보여준다. <strong><em>변경가능한 객체(mutable object)</em></strong>는 시간에 따라 변화하는 동작을 하며, 바인딩된 모든 이름을 통해 알 수 있다. 파이썬의 리스트는 변경가능한 객체의 한 예이다. <strong><em>변경불가능한 객체(immutable object)</em></strong>는 만들어진 이후에 수정될 수 없다. 이들은 <code class=\"language-text\">string.join()</code>과 같은 함수가 새로운 객체의 값을 계산하기 위해 쓰일 수 있다. 이에 대해 생각해 볼 때, 파이썬에서 모든 것이 객체이기 때문에 이러한 <strong>“이분법”</strong>적인 구분이 필요할 수 밖에 없다. 만약 정수형이 변경불가능했다면 우리는 프로그램에서 숫자 <em>2</em>의 의미를 바꿀 수 있었을 것이다!  </p>\n<p>그러나 “변경가능한 객체는 바뀔 수 있고, 변경불가능한 객체는 바뀔 수 없다”고 말할 수는 없다. 다음의 예제를 고려해보자.  </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">first_names <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'George'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Bill'</span><span class=\"token punctuation\">]</span>\nlast_names <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'Smith'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Jones'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Williams'</span><span class=\"token punctuation\">]</span>\nname_tuple <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>first_names<span class=\"token punctuation\">,</span> last_names<span class=\"token punctuation\">)</span>\n\nfirst_names<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token string\">'Igor'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>파이썬에서의 튜플은 변경불가능하다. 우리는 <code class=\"language-text\">name_tuple</code>으로 바인딩된 튜플 객체를 바꿀 수는 없다. 그러나 변경불가능한 컨테이너는 리스트와 같은 변경가능한 객체의 참조가 포함할 수 있다. 그러므로 <code class=\"language-text\">name_tuple</code>이 변경불가능하다고 해도, 마지막 줄에서 ‘Igor’가 <code class=\"language-text\">first_name</code>에 추가될 때 <code class=\"language-text\">name_tuple</code>은 변경된다. 이는 때로 유용할 수 있는 미묘한 부분이다.  </p>\n<p>이제는 파이썬에서 함수 호출이 어떻게 작동하는지 거의 알 수 있어야 한다. 만약 <code class=\"language-text\">foo(bar)</code>를 호출한다면, 함수가 호출될 때 foo 함수의 스코프 안에서 인수 bar가 바인딩된 객체에 바인딩을 하기만 하면 된다. <strong>만약</strong> <code class=\"language-text\">bar</code><strong>가 변경가능한 객체를 가리키고</strong> <code class=\"language-text\">foo</code><strong>가</strong> <code class=\"language-text\">bar</code><strong>의 값을 바꾼다면, 이는 함수 스코프 바깥에서도 적용된다.</strong>  </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    bar<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># >> [42]</span>\n\nanswer_list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nfoo<span class=\"token punctuation\">(</span>answer_list<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>answer_list<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># >> [42]</span></code></pre></div>\n<p>반면에 <code class=\"language-text\">bar</code>가 변경불가능한 객체를 가리킨다면, <code class=\"language-text\">foo</code> 함수가 할 수 있는 것은 함수 내부의 <em>namespace</em>에 <code class=\"language-text\">bar</code> 라는 이름을 만들고 완전히 다른 객체에 바인딩하는 것뿐이다.  </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    bar <span class=\"token operator\">=</span> <span class=\"token string\">'new value'</span>\n    <span class=\"token keyword\">print</span> <span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># >> 'new value'</span>\n\nanswer_list <span class=\"token operator\">=</span> <span class=\"token string\">'old value'</span>\nfoo<span class=\"token punctuation\">(</span>answer_list<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>answer_list<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># >> 'old value'</span></code></pre></div>\n<p>이제 왜 파이썬이 <em>“call-by-value”</em>나 <em>“call-by-reference”</em>가 아닌지 명확해졌을 거라고 생각한다. 파이썬에서의 변수는 메모리의 위치를 가리키는 것이 아니다. 단순히 파이썬 객체와의 바인딩을 뜻할 뿐이다. “모든 것이 객체다”라는 말이 파이썬에 익숙하지 않은 사람들에게는 혼란의 원인이 될 수 있지만, 이는 강력하고 유연한 언어 구조를 갖게 해준다.  </p>","frontmatter":{"title":"(번역글) Python은 call-by-value일까, call-by-reference일까?","date":"March 09, 2018"}}},"pageContext":{"slug":"/python/call-by-value-or-reference/","previous":{"fields":{"slug":"/cpp/modern-cpp-1/"},"frontmatter":{"title":"(C++11) Range-Based for Loop","category":"C++","draft":false}},"next":{"fields":{"slug":"/cpp/vs2017-win32/"},"frontmatter":{"title":"Visual Studio 2017에서 Win32 콘솔 응용 프로그램 프로젝트 만들기","category":"C++","draft":false}}}},"staticQueryHashes":["3128451518","521680639"]}